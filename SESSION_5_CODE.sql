USE SQL_POWER_BATCH_202308;

SELECT * FROM MED_2023;

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023;

--WHAT IS HARD CODED VALUES

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
'AUSTRALIA' AS COUNTRY,
2023 AS YEAR,
'DV ANALYTICS' AS INSTITUE,
GETDATE() AS CURRENT_DATE_TIME
FROM MED_2023;

--HOW TO GET TABLE FROM HARD CODED VALUES

SELECT 'DEV' AS NAME, 'PHD' AS EDUCATION, 41 AS AGE INTO STU_DETAILS_NEW
UNION ALL
SELECT 'KAVITHA' AS NAME, 'MBA' AS EDUCATION, 23 AS AGE
UNION ALL
SELECT 'NIRMAL' AS NAME, 'BTECH' AS EDUCATION, 40 AS AGE;

SELECT * FROM STU_DETAILS_NEW;

--HOW TO SELECT RANDOM RECORDS FROM A TABLE

SELECT
TOP 100 *
FROM MED_2023
ORDER BY NEWID();

SELECT
TOP 100 
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
ORDER BY NEWID();

--HOW TO RANK DATA 
--USING	
--1. RANK() OVER
--2. DENSE_RANK() OVER
--==============================

SELECT 
STATE_CODE,
COMPANY,
COUNT(CUSTOMER_ID) AS SUBS
INTO MED_NEW_SUMMARY
FROM MED_2023
GROUP BY STATE_CODE,COMPANY
ORDER BY 1,2;

SELECT * FROM MED_NEW_SUMMARY ORDER BY 1,2;

--LETS RANK THE COMPANY SUBS IN HIGHEST TO LOWEST ORDER USING RANK OVER ()

SELECT
STATE_CODE,
COMPANY,
SUBS,
RANK() OVER (PARTITION BY STATE_CODE ORDER BY SUBS DESC) AS SUBS_RANKING
FROM MED_NEW_SUMMARY;

--LETS RANK THE COMPANY SUBS IN HIGHEST TO LOWEST ORDER USING DENSE_RANK () OVER

SELECT
STATE_CODE,
COMPANY,
SUBS,
DENSE_RANK() OVER (PARTITION BY STATE_CODE ORDER BY SUBS DESC) AS SUBS_RANKING
FROM MED_NEW_SUMMARY;

--INTERVIEW QUESTION

--WHAT IS TEH DIFFERENCE BETWEEN RANK() OVER AND DENSE_RANK() OVER ?

--RANK() OVER WILL OMIT THE NEXT HIGHEST RANKING ORDER WHERE VALUES ARE SAME
--DENSE-RANK() OVER WILL NOT OMIT THE NEXT HIGHEST ORDER WHERE VALUES ARE SAME

--LETS DO MORE PRACTICALS

SELECT * FROM SCORE_DATA1_2023;

--GET STUDENT WISE SCORE RANKING BASED ON SUBJECT SCORE FROM TTHE LARGEST TO SMALLEST ORDER

SELECT
STU_NAME,
SUBJECT,
SCORE,
RANK() OVER (PARTITION BY STU_NAME ORDER BY SCORE DESC) AS SCORE_RANKING
FROM SCORE_DATA1_2023;

--LETS DO UNDERSTAND WHY DENSE_RANK() OVER

SELECT * FROM SCORE_DATA2_2023;

SELECT 
STU_NAME,
SUBJECT,
SCORE,
RANK() OVER (PARTITION BY STU_NAME ORDER BY SCORE DESC) AS SCORE_RANKING
FROM SCORE_DATA2_2023;

SELECT 
STU_NAME,
SUBJECT,
SCORE,
DENSE_RANK() OVER (PARTITION BY STU_NAME ORDER BY SCORE DESC) AS SCORE_RANKING
FROM SCORE_DATA2_2023;

--RANK OVER EXAMPLES

SELECT * FROM LAPTOP_SALES_2023;

--GET COUNTRY AND YEAR WISE LAPTOP SALES IN RANKING ORDER OF HIGHEST TO LOWEST

SELECT
COUNTRY,
YEAR,
LAPTOP,
SALES,
DENSE_RANK() OVER (PARTITION BY COUNTRY,YEAR ORDER BY SALES DESC) AS SALES_RANKING
FROM LAPTOP_SALES_2023;

--Q1. GET 3RD AND 4TH HIGHEST SELLING LAPTOPS IN EACH COUNTRY AND YEAR WISE

--I WILL ANSWER THIS USING A SUB-QUERY

SELECT
COUNTRY,
YEAR,
LAPTOP,
A.SALES_RANKING
FROM 
	(SELECT
	COUNTRY,
	YEAR,
	LAPTOP,
	SALES,
	DENSE_RANK() OVER (PARTITION BY COUNTRY,YEAR ORDER BY SALES DESC) AS SALES_RANKING
	FROM LAPTOP_SALES_2023) AS A
WHERE SALES_RANKING IN (3,4);

--Q2. GET YEAR AND LAPTOP WISE HIGHEST SELLING COUNTRIES IN RANKING ORDER

SELECT
LAPTOP,
YEAR,
COUNTRY,
SALES,
DENSE_RANK() OVER (PARTITION BY LAPTOP,YEAR ORDER BY SALES DESC) AS SALES_RANKING
FROM LAPTOP_SALES_2023;

--Q3. GET 2ND,3RD AND 4TH HIGHEST SCORING SUBJECTS

SELECT * FROM RANKING_TEST_DATA;

SELECT
STU_NAME,
YEAR,
SUBJECT,
SCORE,
SCORE_RANKING
FROM
	(SELECT
	STU_NAME,
	YEAR,
	SUBJECT,
	SCORE,
	DENSE_RANK() OVER (PARTITION BY STU_NAME,YEAR ORDER BY SCORE DESC) AS SCORE_RANKING
	FROM RANKING_TEST_DATA) AS A
WHERE SCORE_RANKING IN (2,3,4);

--USE OF PARTITION BY	SUMMARIZE DATA BY 
--PARENT TOTAL
--CUMULATIVE 
--=====================

SELECT * FROM MED_NEW_SUMMARY;

SELECT
STATE_CODE,
COMPANY,
SUBS,
SUM(SUBS) OVER (PARTITION BY STATE_CODE,COMPANY ORDER BY STATE_CODE) AS TOTOAL_SUBS
FROM MED_NEW_SUMMARY;


--EXAMPLE

SELECT 'BANGALORE' AS CITY, 'APPLE' AS LAPTOP,12000 AS UNITS_SOLD INTO PROD_SALES_NEW_2023
UNION ALL
SELECT 'BANGALORE' AS CITY, 'DELL' AS LAPTOP,11000 AS UNITS_SOLD
UNION ALL
SELECT 'BANGALORE' AS CITY, 'HP' AS LAPTOP,16000 AS UNITS_SOLD
UNION ALL
SELECT 'CHENNAI' AS CITY, 'APPLE' AS LAPTOP,10000 AS UNITS_SOLD
UNION ALL
SELECT 'CHENNAI' AS CITY, 'DELL' AS LAPTOP,12000 AS UNITS_SOLD
UNION ALL
SELECT 'CHENNAI' AS CITY, 'HP' AS LAPTOP,15000 AS UNITS_SOLD;

SELECT * FROM PROD_SALES_NEW_2023;

SELECT
CITY,
SUM(UNITS_SOLD) AS TOTAL_UNITS_SOLD
FROM PROD_SALES_NEW_2023
GROUP BY CITY;

SELECT
A.CITY,
A.LAPTOP,
A.UNITS_SOLD,
B.TOTAL_UNITS_SOLD,
FORMAT((CAST(A.UNITS_SOLD AS FLOAT)/B.TOTAL_UNITS_SOLD),'P0') AS MS
FROM PROD_SALES_NEW_2023 AS A
LEFT JOIN
	(SELECT
	CITY,
	SUM(UNITS_SOLD) AS TOTAL_UNITS_SOLD
	FROM PROD_SALES_NEW_2023
	GROUP BY CITY) AS B
ON
A.CITY=B.CITY;

--OR

SELECT * FROM PROD_SALES_NEW_2023;

SELECT
CITY,
LAPTOP,
UNITS_SOLD,
SUM(UNITS_SOLD) OVER (PARTITION BY CITY ORDER BY CITY) AS TOTAL_UNITS_SOLD,
FORMAT((CAST(UNITS_SOLD AS FLOAT)/SUM(UNITS_SOLD) OVER (PARTITION BY CITY ORDER BY CITY)),'P0') AS MS
FROM PROD_SALES_NEW_2023
GROUP BY CITY,LAPTOP,UNITS_SOLD;

--WE USE PARTITION BY TO HAVE A ROW LEVEL CALCULATION IN THE SAME QUERY


--EXAMPLE

SELECT * FROM MED_NEW_SUMMARY ORDER BY 1,2;

--TO GET STATE_CODE WISE COMPANY SUBS %

SELECT
A.STATE_CODE,
A.COMPANY,
A.SUBS,
B.TOTAL_SUBS,
FORMAT((CAST(A.SUBS AS FLOAT)/B.TOTAL_SUBS),'P0') AS TOTAL_SUBS_PERCENTAGE
FROM MED_NEW_SUMMARY AS A
LEFT JOIN
(SELECT STATE_CODE,SUM(SUBS) AS TOTAL_SUBS FROM MED_NEW_SUMMARY GROUP BY STATE_CODE) AS B
ON
A.STATE_CODE=B.STATE_CODE
ORDER BY 1,2;

--WE CAN REDUCE THESE SUB-QUERIES TO FEW LINES USING PARTITION BY

SELECT
STATE_CODE,
COMPANY,
SUBS,
SUM(SUBS) OVER (PARTITION BY STATE_CODE ORDER BY STATE_CODE) AS TOTAL_SUBS,
FORMAT((CAST(SUBS AS FLOAT)/SUM(SUBS) OVER (PARTITION BY STATE_CODE ORDER BY STATE_CODE)),'P0') AS SUBS_PERCENTAGE
FROM MED_NEW_SUMMARY
GROUP BY STATE_CODE,COMPANY,SUBS;

--EXAMPL-1
SELECT * FROM STATE_SALES_2023;

--GET PRODUCT WISE STATES MARKET SHARE IN %

SELECT
PRODUCT,
STATE,
SALES,
SUM(SALES) OVER (PARTITION BY PRODUCT ORDER BY PRODUCT) AS TOTAL_SALES,
FORMAT((SALES/SUM(SALES) OVER (PARTITION BY PRODUCT ORDER BY PRODUCT)),'P0') AS STATES_MS
FROM STATE_SALES_2023
GROUP BY PRODUCT,STATE,SALES;

--EXAMPLE-2

SELECT * FROM CITY_SALES_2023;

--GET CITY AND YEARS WISE PRODUCT MARKET SHARE IN %

SELECT
CITY,
YEAR,
PRODUCT,
UNITS,
SUM(UNITS) OVER (PARTITION BY CITY,YEAR ORDER BY YEAR) AS TOTAL_UNITS_SOLD_YEAR,
FORMAT((UNITS/SUM(UNITS) OVER (PARTITION BY CITY,YEAR ORDER BY YEAR)),'P0') AS CITY_YEAR_PRODUCT_MS
FROM CITY_SALES_2023
GROUP BY CITY,YEAR,PRODUCT,UNITS ;

--HOW TO CUMULATIVE SUM
--============================
SELECT * FROM MED_NEW_SUMMARY ORDER BY 1;

SELECT
STATE_CODE,
COMPANY,
SUBS,
SUM(SUBS) OVER (PARTITION BY STATE_CODE ORDER BY SUBS) AS CUMULATIVE_SUBS
FROM MED_NEW_SUMMARY
GROUP BY STATE_CODE,COMPANY,SUBS;

--EXAMPLE-1

SELECT * FROM STATE_SALES_2023;

SELECT
PRODUCT,
STATE,
SALES,
SUM(SALES) OVER (PARTITION BY PRODUCT ORDER BY SALES) AS CUM_SALES
FROM STATE_SALES_2023
GROUP BY PRODUCT,STATE,SALES;

--EXAMPLE-2

SELECT * FROM CITY_SALES_2023 ORDER BY 2,3;

SELECT
CITY,
YEAR,
PRODUCT,
UNITS,
SUM(UNITS) OVER (PARTITION BY CITY,YEAR ORDER BY UNITS) AS CUM_UNITS_SOLD
FROM CITY_SALES_2023
GROUP BY CITY,YEAR,PRODUCT,UNITS;

--ADVANCE SQL PROGRAMMING USING RANKING AND PARTITION BY TOGETHER

SELECT * FROM  MED_NEW_SUMMARY;

SELECT 
A.STATE_CODE,
A.COMPANY,
A.SUBS,
A.SUBS_MS,
A.CUM_SUBS,
DENSE_RANK() OVER (PARTITION BY STATE_CODE ORDER BY SUBS ASC) AS SUBS_RANKING
FROM 
	(SELECT
	STATE_CODE,
	COMPANY,
	SUBS,
	SUM(SUBS) OVER (PARTITION BY STATE_CODE ORDER BY STATE_CODE) AS TOTAL_SUBS,
	FORMAT((CAST(SUBS AS FLOAT)/SUM(SUBS) OVER (PARTITION BY STATE_CODE ORDER BY STATE_CODE)),'P0') AS SUBS_MS,
	SUM(SUBS) OVER (PARTITION BY STATE_CODE ORDER BY SUBS) AS CUM_SUBS
	FROM MED_NEW_SUMMARY
	GROUP BY STATE_CODE,COMPANY,SUBS) AS A
ORDER BY 1,3;



--LAG CALCULATION
--=======================

SELECT 'KFC' AS RESTAURANT, 'PANKAJ' AS CUST_NAME, '02/02/2023' AS VISITS_DATE, 1200 AS SPENT INTO RESTAURANT_CUSTOMER_SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'PANKAJ' AS CUST_NAME, '03/12/2023' AS VISITS_DATE, 1000 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'PANKAJ' AS CUST_NAME, '03/18/2023' AS VISITS_DATE, 800 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'PANKAJ' AS CUST_NAME, '03/19/2023' AS VISITS_DATE, 1900 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'PANKAJ' AS CUST_NAME, '03/28/2023' AS VISITS_DATE, 2400 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'LAXMAN' AS CUST_NAME, '02/07/2023' AS VISITS_DATE, 1000 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'LAXMAN' AS CUST_NAME, '02/12/2023' AS VISITS_DATE, 1900 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'LAXMAN' AS CUST_NAME, '03/18/2023' AS VISITS_DATE, 1800 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'LAXMAN' AS CUST_NAME, '03/22/2023' AS VISITS_DATE, 900 AS SPENT
UNION ALL
SELECT 'KFC' AS RESTAURANT, 'LAXMAN' AS CUST_NAME, '03/28/2023' AS VISITS_DATE, 400 AS SPENT;

SELECT * FROM RESTAURANT_CUSTOMER_SPENT;

SELECT
RESTAURANT,
CUST_NAME,
VISITS_DATE,
SPENT,
LAG(VISITS_DATE,1) OVER (PARTITION BY RESTAURANT,CUST_NAME ORDER BY VISITS_DATE) AS PREVIOUS_VISIT_DATE,
DATEDIFF(DAY,LAG(VISITS_DATE,1) OVER (PARTITION BY RESTAURANT,CUST_NAME ORDER BY VISITS_DATE),VISITS_DATE) AS DAYS_GAP,
LAG(SPENT,1) OVER (PARTITION BY RESTAURANT,CUST_NAME ORDER BY VISITS_DATE) AS PREVIOUS_SPENT_AMOUNT,
(LAG(SPENT,1) OVER (PARTITION BY RESTAURANT,CUST_NAME ORDER BY VISITS_DATE)-SPENT) AS SPENT_DIFFERENCE
INTO RESTAURANT_CUSTOMER_SPENT_V1
FROM RESTAURANT_CUSTOMER_SPENT
GROUP BY RESTAURANT,CUST_NAME,VISITS_DATE,SPENT;

SELECT * FROM RESTAURANT_CUSTOMER_SPENT_V1;


SELECT
RESTAURANT,
CUST_NAME,
COUNT(CUST_NAME) AS TOTAL_VISITS,
AVG(DAYS_GAP) AS AVG_DAYS_GAP_VISIT,
SUM(SPENT) AS TOTAL_SPENT,
AVG(SPENT_DIFFERENCE) AS AVG_SPENT_DIFF
FROM RESTAURANT_CUSTOMER_SPENT_V1
GROUP BY RESTAURANT,CUST_NAME;


--EXAMPLE

SELECT * FROM RESTAURANT_DATA ORDER BY 1,2,3;

SELECT
RESTAURANT_ID,
CUST_NAME,
AGE,
DATE_OF_VISIT,
SPENT,
LAG(DATE_OF_VISIT,1) OVER (PARTITION BY RESTAURANT_ID,CUST_NAME ORDER BY DATE_OF_VISIT) AS PREVIOUS_VISIT_DATE,
DATEDIFF(DAY,LAG(DATE_OF_VISIT,1) OVER (PARTITION BY RESTAURANT_ID,CUST_NAME ORDER BY DATE_OF_VISIT),DATE_OF_VISIT) AS DAYS_GAP,
LAG(SPENT,1) OVER (PARTITION BY RESTAURANT_ID,CUST_NAME ORDER BY DATE_OF_VISIT) AS PREVIOUS_SPENT_AMOUNT,
(LAG(SPENT,1) OVER (PARTITION BY RESTAURANT_ID,CUST_NAME ORDER BY DATE_OF_VISIT)-SPENT) AS SPENT_DIFF
INTO RESTAURANT_DATA_V1
FROM RESTAURANT_DATA
GROUP BY RESTAURANT_ID,CUST_NAME,AGE,DATE_OF_VISIT,SPENT;

SELECT * FROM RESTAURANT_DATA_V1;

SELECT
RESTAURANT_ID,
CUST_NAME,
COUNT(CUST_NAME) AS TOTAL_VISITS,
SUM(SPENT) AS TOTAL_SPENT,
AVG(DAYS_GAP) AS AVG_DAYS_GAP_IN_VISIT,
AVG(SPENT_DIFF) AS AVG_SPENT_DIFF
FROM RESTAURANT_DATA_V1
GROUP BY RESTAURANT_ID,CUST_NAME
ORDER BY 1,2;

--HOW TO CREATE A ROW NUMBER
--===============================

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
ROW_NUMBER() OVER (ORDER BY CUSTOMER_ID) AS ROW_NUM
FROM MED_2023;

--OR

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
ROW_NUMBER() OVER (ORDER BY (SELECT(NULL))) AS ROW_NUM
FROM MED_2023;

--INTERVIEW QUESTION

SELECT 'RAVI' AS NAME INTO STU_ALL
UNION ALL
SELECT 'KOYAL' AS NAME
UNION ALL
SELECT 'KAVYA' AS NAME
UNION ALL
SELECT 'DAVID' AS NAME
UNION ALL
SELECT 'DINKY' AS NAME;

SELECT * FROM STU_ALL;

--TO GET THE STUDNETS NAME IN REVERSE ORDER

SELECT
NAME,
ROW_NUMBER() OVER (ORDER BY (SELECT(NULL))) AS ROW_NUM
FROM STU_ALL
ORDER BY 2 DESC;

--USE OF WITH CLAUSE
--=======================


CREATE TABLE PROD_SALES_NEW
(PROD_NAME VARCHAR(15),
SALES INT);

SELECT * FROM PROD_SALES_NEW;

INSERT INTO PROD_SALES_NEW VALUES ('APPLE',23000);
INSERT INTO PROD_SALES_NEW VALUES ('DELL',32000);
INSERT INTO PROD_SALES_NEW VALUES ('LENOVO',56000);
INSERT INTO PROD_SALES_NEW VALUES ('HP',21000);
INSERT INTO PROD_SALES_NEW VALUES ('ACER',90000);
INSERT INTO PROD_SALES_NEW VALUES ('SAMSUNG',70000);

SELECT * FROM PROD_SALES_NEW;

--TO GET THE SALES ABIVE AVG SALES BY ALL PRODUCTS

--STEP-1

WITH TEMP_TABLE (AVG_SALES) AS (SELECT AVG(SALES) FROM PROD_SALES_NEW)

--STEP-2

SELECT
PROD_NAME,
SALES,
AVG_SALES
FROM PROD_SALES_NEW,TEMP_TABLE
WHERE PROD_SALES_NEW.SALES >= TEMP_TABLE.AVG_SALES;

--TEST

CREATE TABLE departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(50)
);

SELECT * FROM departments;

INSERT INTO departments (department_id, department_name)
VALUES
    (1, 'HR'),
    (2, 'Finance'),
    (3, 'Engineering');

SELECT * FROM departments;


CREATE TABLE employees_2023 (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(100),
    department_id INT,
    salary DECIMAL(10, 2),
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);

SELECT * FROM employees_2023;

INSERT INTO employees_2023 (employee_id, employee_name, department_id, salary)
VALUES
    (1, 'Alice', 1, 50000.00),
    (2, 'Bob', 1, 55000.00),
    (3, 'Charlie', 2, 60000.00),
    (4, 'David', 2, 62000.00),
    (5, 'Eve', 3, 70000.00),
	(6, 'Jaga', 3, 70000.00),
	(7, 'souvik', 2, 62000.00),
	(8, 'bunty', 1, 55000.00);

SELECT * FROM employees_2023;

SELECT * FROM departments;
SELECT * FROM employees_2023;

--STEP-1
WITH AvgSalaries AS (
    SELECT
        department_id,
        AVG(salary) AS avg_salary
    FROM employees_2023
    GROUP BY department_id
)

--STEP-2
SELECT
    d.department_name,
    a.avg_salary
FROM departments d
JOIN AvgSalaries a ON d.department_id = a.department_id;

--we will count no of employee in each department
SELECT * FROM departments;

WITH NO_OF_EMPLOYEE AS (
SELECT
DEPARTMENT_ID,
COUNT(DEPARTMENT_ID) AS COUNT_DEP
FROM employees_2023
GROUP BY DEPARTMENT_ID)

SELECT
A.DEPARTMENT_NAME,
B.COUNT_DEP
FROM departments AS A
LEFT JOIN
NO_OF_EMPLOYEE AS B
ON A.DEPARTMENT_ID=B.DEPARTMENT_ID;




--TEST-2

SELECT
STATE_CODE,
COMPANY,
COUNT(CUSTOMER_ID) AS SUBS
INTO MED_SUMMARY_NEW
FROM MED_2023
GROUP BY STATE_CODE,COMPANY
ORDER BY 1,2;

SELECT * FROM MED_SUMMARY_NEW ORDER BY 1,2;

--STEP-1
WITH AVG_SUBS_STATE AS 
(SELECT 
STATE_CODE,
AVG(SUBS) AS AVG_BASE 
FROM MED_SUMMARY_NEW 
GROUP BY STATE_CODE)

--STEP-2
SELECT
A.STATE_CODE,
A.COMPANY,
A.SUBS,
B.AVG_BASE
FROM MED_SUMMARY_NEW AS A
LEFT JOIN
AVG_SUBS_STATE AS B
ON
A.STATE_CODE=B.STATE_CODE
WHERE A.SUBS >= B.AVG_BASE;

--WITH CLAUSE AS PRECEDED LOADING OF TABLES, MEANS A PROGRAM CALL TEMPORARY TABLE TO BE CREATED BEFORE THE PROGRAM TO GET OUTPUT

--CREATING VIEWS
--=====================

CREATE VIEW MED_SUM_VIEW_2023
AS
SELECT
STATE_CODE,
COMPANY,
GENDER,
FORMAT(AVG(AGE),'N0') AS AVG_AGE,
FORMAT(COUNT(CUSTOMER_ID),'N0') AS SUBS,
FORMAT(SUM(NO_OF_TRIPS),'N0') AS VISITS,
FORMAT(SUM(SPENT_AMOUNT),'C0') AS TOTAL_SPENT
FROM MED_2023
GROUP BY STATE_CODE,COMPANY,GENDER;

SELECT * FROM MED_SUM_VIEW_2023;

--VIEW STORES AS A QUERY NOT AS A TABLE
--HENCE, VIEW DOES NOT OCCUPY THE DATABASE MEMORT MORE LIKE A TABLE

--NOTE: A VIEW CAN WORK LIKE A TABLE, AND ALSO IT CAN BE IMPORTED AND EXPORTED AS WELL

--CAN WE USE ORDER BY CLAUSE IN A VIEW?

CREATE VIEW MED_SUM_VIEW_2023_V1
AS
SELECT
STATE_CODE,
COMPANY,
GENDER,
FORMAT(AVG(AGE),'N0') AS AVG_AGE,
FORMAT(COUNT(CUSTOMER_ID),'N0') AS SUBS,
FORMAT(SUM(NO_OF_TRIPS),'N0') AS VISITS,
FORMAT(SUM(SPENT_AMOUNT),'C0') AS TOTAL_SPENT
FROM MED_2023
GROUP BY STATE_CODE,COMPANY,GENDER
ORDER BY 1,2,3;

--WE CAN NOT USE ORDER BY CLAUSE IN A VIEW


--TO DROP A VIEW

DROP VIEW MED_SUM_VIEW_2023;


--WHAT IS A STORE PROCEDURE
--==============================


--PROGRAM-1
SELECT CUSTOMER_ID,COMPANY,GENDER,AGE,STATE_CODE,SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY='APPOLO' AND GENDER='MALE' AND AGE > 40 AND SPENT_AMOUNT>= 500;


--PROGRAM-2
SELECT CUSTOMER_ID,COMPANY,GENDER,AGE,STATE_CODE,SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY='CIPLA' AND GENDER='FEMALE' AND AGE > 60 AND SPENT_AMOUNT>= 1000;


--PROGRAM-3
SELECT CUSTOMER_ID,COMPANY,GENDER,AGE,STATE_CODE,SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY='GENO' AND GENDER='FEMALE' AND AGE > 50 AND SPENT_AMOUNT>= 1100;

--IN THIS ABOVE PROGRAM-1 TO PROGRAM-3
--WHAT WE SEE IS THAT, THE PROGRAM IS REPEATITIVE AND WE CALL THIS AS REDUNDANT PROGRAMMING

--WE NEED TO UNDERSTAND WHY THE PROGRAM IS REDUNDANT
--THE PROGRAM IS REDUNDANT BECAUSE OF THESE DYNAMIC VALUES

--1. COMPANY VALUE
--2. GENDER VALUE
--3. AGE VALUE
--4. SPENT VALUE

--TO AVOID SUCH MANUAL AND REPEATITIVE TASKS , WE SHOULD USE A STORE PROCEDURE

CREATE PROCEDURE MED_STORE_PROC_2023
@COMP_VALUE VARCHAR(15),
@GEN_VALUE VARCHAR(15),
@AGE_VALUE VARCHAR(15),
@SPENT_VALUE VARCHAR(15)

AS
BEGIN

SELECT CUSTOMER_ID,COMPANY,GENDER,AGE,STATE_CODE,SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY=@COMP_VALUE AND GENDER=@GEN_VALUE AND AGE > @AGE_VALUE AND SPENT_AMOUNT>= @SPENT_VALUE

END;

EXECUTE MED_STORE_PROC_2023 'APPOLO','FEMALE',50,500;
EXECUTE MED_STORE_PROC_2023 'CIPLA','FEMALE',60,500;
EXECUTE MED_STORE_PROC_2023 'RANBAXY','MALE',60,1000;

--HOW TO DROP A PROCEDURE

DROP PROC MED_STORE_PROC_2023;

--SQL LOOPING
--===================

DECLARE @COUNTER INT
SET @COUNTER=1
WHILE ( @COUNTER <= 10)
BEGIN
     PRINT 'COUNTER VALUE IS=' + CONVERT(VARCHAR,@COUNTER)
	 SET @COUNTER=@COUNTER+1
END;


--LOOPING STEP WISE FORWARDING LOOKING

DECLARE @COUNTER INT
SET @COUNTER=1
WHILE ( @COUNTER <= 20)
BEGIN
     IF @COUNTER % 2 =1
	 BEGIN
	 SET @COUNTER=@COUNTER + 1
	 CONTINUE
	 END
		PRINT 'COUNTER VALUE IS=' + CONVERT(VARCHAR,@COUNTER)
		SET @COUNTER=@COUNTER + 1	
END;

--SQL FUNCTIONS
--====================

--THERE ARE 4 TYPES OF SQL FUNCTIONS
--1. TABLE-VALUE FUNCTION
--2. SCALAR-VALUE FUNCTION
--3. AGGREGATE FUNCTION
--4. SYSTEM FUNCTION (WINDOW FUNCTION)

--1. TABLE-VALUE FUNCTION

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE GENDER='FEMALE';

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE GENDER='MALE';

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE GENDER='UNISEX';

CREATE FUNCTION SELECT_GEN (@GEN_VAL CHAR(10))
RETURNS TABLE
AS
RETURN 
(SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE GENDER=@GEN_VAL);

SELECT * FROM SELECT_GEN('FEMALE');
SELECT * FROM SELECT_GEN('MALE');
SELECT * FROM SELECT_GEN('UNISEX');


--2. SCALAR-VALUE FUNCTION

SELECT 100+200 AS VALUE;

SELECT 100*200 AS VALUE;

SELECT 100-200 AS VALUE;

SELECT 100/200 AS VALUE;

SELECT 100%200 AS VALUE;

CREATE FUNCTION USE_100 (@NUM INT)
RETURNS DECIMAL
AS
BEGIN
RETURN (@NUM-100)
END;


SELECT [dbo].[USE_100](1000);


SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
([dbo].[USE_100](SPENT_AMOUNT)) AS NEW_SPENT
FROM MED_2023;

--AGGREGATE FUNCTION

COUNT()
SUM()
AVG()
MIN()
MAX()
STDEV()

--WINDOWS FUNCTIONS
SUBSTRING()
PATINDEX()
CHARINDEX()
STUFF()
RANK() OVER
DENSE_RANK() OVER
PIVOT()
UNPIVIT()

--HOW TO CREATE AN INDEX

CREATE INDEX MED_INDEX ON MED_2023 (CUSTOMER_ID,COMPANY,GENDER,AGE,STATE_CODE,SPENT_AMOUNT);

--WE CREATE INDEX BY SELECTING THE FIELDS WHICH ARE CALL IN EACH AND EVERY PROGRAMMING CAN BE CALLED ON THE TABLE AS MED_2023

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
TOWN,NO_OF_TRIPS,
SPENT_AMOUNT
FROM MED_2023;

--WE USE AN INDEX WITH A COLUMN NAME TO PULL DATA FASTER

--HOW TO MAKE YOUR SQL PROGRAMMING PERFORMANCE TUNING?
--=====================================
1. Performance tuning in SQL involves optimizing the performance of your database queries 
and operations to ensure that they run efficiently and provide fast response times.

There are several ways to perform performance tuning in SQL, ranging from query optimization 
to server configuration and indexing. Here are some common strategies:

1. Query Optimization:

   Use appropriate indexing: Ensure that your queries utilize indexes on columns used in WHERE, JOIN, and ORDER BY clauses.

   Avoid using SELECT *: Only select the columns you need to minimize data transfer and processing.

2. Optimize JOINs: Use the appropriate type of JOIN (INNER, LEFT, RIGHT, etc.) and ensure join columns are indexed.

3. Use efficient filtering: Apply filters early in the query to reduce the number of rows processed.

4. Optimize subqueries: Use correlated subqueries carefully, and consider using derived tables or common table expressions (CTEs).

5. Avoid using functions in WHERE clauses: Functions can prevent index usage; consider moving calculations outside the query.

6. Indexing Strategies:
	Create proper indexes: Use indexes on columns frequently used in queries, but avoid over-indexing as it can impact write performance.
	Use composite indexes: Create indexes on combinations of columns used together in queries.
	Maintain indexes: Regularly rebuild or reorganize indexes to prevent fragmentation.

7. Database Design:
	Normalize tables: Design your database with appropriate normalization to reduce data redundancy.
	Denormalize for performance: In some cases, denormalization can improve read performance for certain queries.






































































